"""решение 1 прототипа через lru_cache"""
from functools import lru_cache

# вешаем декоратор, который в памяти будет сохранять результаты функции
@lru_cache(None)
def f(n):
    if n <= 10:
        return n
    else:
        return n - 7 + f(n - 21)

# этим действием сохраняем в памяти результаты, идем снизу
# в верх, потому что в else шаг "-21", а результат выдаст программа
# только при n <= 10
for n in range(10, 190000): f(n)

print((f(185734)-f(185650))//f(40))

"""решение 2 прототипа через lru_cache"""
# В этом прототипе главное понять, как работает наш алгоритм.
# Что считается первым, а что последним. Потому что на
# основе этой информации можно понять, что мы первее будет просчитывать в памяти.
from functools import lru_cache

# вешаем декоратор, который в памяти будет сохранять результаты функции
@lru_cache(None)
def f(n):
    if n > 40:
        return f(n-4) + 3020
    else:
        return 3*(g(n-2) - 15)

# на обе функции
@lru_cache(None)
def g(n):
    if n >= 301208:
        return 10*n+50
    else:
        return g(n+7) - 21

# в функцию f() заходит f(2026). 2026 > 40. Следовательно, мы сколько-то
# раз будет уменьшать наше n (n-4) до тех пор, пока оно не станет n < 40.
# После того как мы попали в нижнее условие, у нас вызывается g().
# Но так к в g() попадает n < 40. То оно будет вызывать g(n+7) до тех пор, пока не будет выполняться n >= 301208
# И когда n >= 301208. У нас тогда только пойдет просчет обратно.
# Следовательно, т.к. g(n) считается после f(n). Логично будет его заранее просчитать. А потом
# уже f(n) с учетом в какою сторону мы двигаемся.

# Почему я выбрал такой диапазон? Потому что у нас шаг +7 и
# нам выгодно идти сверху в низ, т. к. значение будет
# строиться на основе результата предыдущего.
for n in range(302000, 10, -1): g(n)

# Аналогично рассуждениям выше можно прийти к выводу,
# почему я перебираю снизу в верх. (n-4)!. Граница 3000,
# потому что нас просят результат f(2026).
for n in range(40, 3000): f(n)

print(f(2026))

